class MeshData
{
  var Vertices : Array[Real3] = Array[Real3]();
  var Indices : Array[Integer] = Array[Integer]();
  var Aabb : Aabb;
  
  function Compute(mesh : Mesh)
  {
    var vertices = mesh.Vertices;
    for(var i = 0; i < vertices.VertexCount; ++i)
      this.Vertices.Add(vertices.GetVertexData(i, VertexSemantic.Position).XYZ);
      
    var indices = mesh.Indices;
    for(var i = 0; i < indices.Count; ++i)
      this.Indices.Add(indices[i]);
      
    this.ComputeAabb();
  }
  
  function ComputeAabb()
  {
    this.Aabb.Set(this.Vertices[0]);
    foreach(var point in this.Vertices)
      this.Aabb.Expand(point);
  }
}

class VHacd : ZilchComponent
{
  [Property] var SubDivisions : Integer3 = Integer3(10, 10, 10);
  [Property] var AabbDrawScale : Real = 0.25;
  [Property] var ComputeHull : Boolean = true;
  [Property] var Recursions : Integer = 0;
  [Property] var DebugIndex : Integer = 0;
  var Voxelizers : Array[Voxelizer] = Array[Voxelizer]();
  var TotalVoxelizers : Array[Voxelizer] = Array[Voxelizer]();
  
  [Dependency] var Model : Model;
  
  var Voxelizer : Voxelizer;
  //[Dependency] var Voxelizer : Voxelizer;
  
  var MeshData : MeshData = MeshData();
  
  var OriginalModel : Cog = null;
  
  function Initialize(init : CogInitializer)
  {
    Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
    Zero.Connect(Zero.Keyboard, Events.KeyDown, this.OnKeyDown);
    Zero.Connect(this.Owner, "Finished", this.OnFinished);
    Zero.Connect(this.Owner, "JobProgress", this.OnJobProgress);
  }

  function OnJobProgress(event : DownloadJobEvent)
  {
    this.GameSession.DispatchEvent(event.EventId, event);
  }

  function OnFinished(event : Event)
  {
    this.Owner.QuickHullRenderer.Clear();
    var zeroVhacd = this.Owner.GetComponentByName("ZeroVHacd") as ZeroVHacd;
    for(var i = 0; i < zeroVhacd.GetHullCount(); ++i)
    {
      scope//if(i == 1)
      {
        var hull = zeroVhacd.GetHull(i);
        var child = this.Space.Create(Archetype.QuickHullRenderer);
        child.AttachTo(this.Owner);
        child.Transform.Translation = Real3();
      
        child.QuickHullRenderer.Clear();
        child.QuickHullRenderer.Add(hull);
        //this.Owner.QuickHullRenderer.Add(hull);
      }
    }
  }

  function OnKeyDown(event : KeyboardEvent)
  {
    if(event.Key == Keys.V)
    {
      timeout(1000)
        this.Compute();
    }
    if(event.Key == Keys.One)
    {
      this.Model.Visible = !this.Model.Visible;
    }
    if(event.Key == Keys.Two)
    {
      if(this.OriginalModel != null)
        this.OriginalModel.Model.Visible = !this.OriginalModel.Model.Visible;
    }
    if(event.Key == Keys.Add || event.Key == Keys.Equal)
      ++this.DebugIndex;
    if(event.Key == Keys.Subtract || event.Key == Keys.Minus)
      --this.DebugIndex;
  }
  
  function OnLogicUpdate(event : UpdateEvent)
  {
    this.Draw();
  }
  
  var Front : Voxelizer;
  var Back : Voxelizer;
  
  function Compute()
  {
    var child = this.Space.CreateAtPosition(Archetype.Model, this.Owner.Transform.WorldTranslation);
    child.AttachTo(this.Owner);
    
    child.Model.Mesh = this.Model.Mesh;
    child.Model.Visible = false;
    this.OriginalModel = child;
    
    this.MeshData.Compute(this.Model.Mesh);
    
    var zeroVhacd = this.Owner.GetComponentByName("ZeroVHacd") as ZeroVHacd;
    zeroVhacd.Compute(this.Model.Mesh);
    
    //var voxelizer = Voxelizer();//this.Owner.Voxelizer;
    //voxelizer.SubDivisions = this.SubDivisions;
    //voxelizer.AabbDrawScale = this.AabbDrawScale;
    //voxelizer.SetMeshData(this.MeshData);
    //voxelizer.Voxelize();
    //
    //this.Voxelizers.Add(voxelizer);
    //this.TotalVoxelizers.Add(voxelizer);
    //
    //this.Recurse(1);
    
    
    //this.Owner.QuickHullRenderer.Clear();
    //for(var i = 0; i < zeroVhacd.GetHullCount(); ++i)
    //{
    //  scope//if(i == 1)
    //  {
    //    var hull = zeroVhacd.GetHull(i);
    //    child = this.Space.Create(Archetype.QuickHullRenderer);
    //    child.AttachTo(this.Owner);
    //    child.Transform.Translation = Real3();
        
    //    child.QuickHullRenderer.Clear();
    //    child.QuickHullRenderer.Add(hull);
    //    //this.Owner.QuickHullRenderer.Add(hull);
    //  }
    //}
    
    
    
    
    
    
    
    
    //foreach(var v in this.Voxelizers)
    //{
    //  v.ComputeHull();
    //  this.Owner.QuickHullRenderer.Add(v.Hull.Hull);
    //  Console.WriteLine("Add");
    //}
    
    // Uses PCA to find principle axes here for some reason
    // Computes convex hull from the 8 vertices of the voxel
    // Measure concavity as ratio of convex hull volume and voxel volume
    
    // When clipping, only take voxel points that are near the clipping plane (some epsilon) and then parse the vertices of the original hull into the two sets to improve accuracy
    
    // Use pca axis of least? spread to pick the best clipping plane.
    // Test several evenly spaced sub-division points along plane normal for best clip plane
    // Measures concavity of each sub-convex hull to get a score?
    // Recurse?
  }
  
  function Recurse(depth : Integer)
  {
    if(depth > this.Recursions)
      return;
      
    var oldVoxelizers = this.Voxelizers;
    var newVoxelizers = Array[Voxelizer]();
    this.Voxelizers = Array[Voxelizer]();
    
    foreach(var voxelizer in oldVoxelizers)
    {
      var front = Voxelizer();
      var back = Voxelizer();
      var axis = (depth + 1) % 3;
      var splitValue = voxelizer.TotalAabb.Center[axis];
      Console.WriteLine("Split", depth, axis, splitValue, voxelizer.TotalAabb);
      voxelizer.Split(axis, splitValue, front, back);
      newVoxelizers {front, back};
      this.TotalVoxelizers {front, back};
    }
    this.Voxelizers = newVoxelizers;
    
    this.Recurse(depth + 1);
  }
  
  function Draw()
  {
    var transform = this.Owner.Transform.WorldMatrix;
    //if(this.Voxelizer != null)
    //{
    //  this.Voxelizer.Draw(transform);
    //}
    
    var index = 0;
    foreach(var voxelizer in this.TotalVoxelizers)
    {
      if(index == this.DebugIndex)
      {
        //voxelizer.Draw(transform);
        //DebugDraw.Add(DebugObb(voxelizer.TotalAabb));
      }
      ++index;
    }
    
    //foreach(var voxelizer in this.Voxelizers)
    //{
    //  voxelizer.Draw(transform);
    //  DebugDraw.Add(DebugObb(voxelizer.TotalAabb));
    //}
    
    //if(this.Front != null)
    //  this.Front.Draw(transform);
    //if(this.Back != null)
    //  this.Back.Draw(transform);
  }
}
